#pragma config(Sensor, S3,     Light,           sensorCOLORRED)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/*
Group: 34
Project: Soccer Robot
TAs: Callum and Julia
*/

bool senseBallOffense()
{
     int ball = 0;
     motor[motorA]=10;
     motor[motorC]=-10;
     while(true) 
     {
         ball = SensorRaw[Light];
   		 if(ball>=400)
   		 {
             wait1Msec(400);
  			 motor[motorA] = 0;
  			 motor[motorC] = 0;
  			 return true; //returns true if it has sensed the ball
   		 }
         /*
         int i = 0;
         float temp = 0, newtemp = 0;
         while(i < 2) //senses two sonar irregularities to identify the ball
         {
             newtemp = SensorValue[S1]; //stores the sensor reading in newtemp
             if(newtemp > temp + 80 || newtemp < temp - 80)
                 i++;

             temp = newtemp; //stores the newtemp reading in temp for next run
         }
         */
     }
}

bool moveBotOffense() //moves bot to the ball
{
	int ball = 0;
	motor[motorA] = -10;
    motor[motorC] = -10;
	while(true)
	{
        ball = SensorRaw[Light];
        if(ball >= 850)
        {
	        motor[motorA] = 0;
     		motor[motorC] = 0;
     		return true;
       }
    }
}

void senseGoalOffense() //uses ultrasonic to sense the goal
{
    motor[motorA] = -10;
    motor[motorC] = 10;
    while(SensorValue[S1] > 100); //spins until it senses the goal

    while(SensorValue[S1] < 100); //continues rotating till it sees nothing
    motor[motorA] = 0;
    motor[motorC] = 0;

    //nMotorEncoder[motorA] = 0;
    motor[motorA] = 10;
    motor[motorC] = -10;
    wait1Msec(1500);
    
    motor[motorA] = 0;
    motor[motorC] = 0;
    /*
    while(SensorValue[S1] >= 100);
    while(SensorValue[S1] < 100); //rotates till it sees the other side

    motor[motorA] = -10;
    motor[motorC] = 10;
    float center = nMotorEncoder[motorA]/2.0;
    nMotorEncoderTarget[motorA] = center;
    nMotorEncoderTarget[motorC] = center;
    nMotorEncoder[motorA] = 0;
    while(nMotorEncoder[motorA] < center);
    motor[motorA] = 0;
    motor[motorC] = 0;
    */
}

void shootBallOffense() //shoots the ball and returns the flipper
                        //to original position
{
     motor[motorA] = -40;
     motor[motorC] = -40;
     wait1Msec(450);
     
     nVolume = 100; //plays a sound file when ball is shot
  	 PlaySoundFile("shoot.rso");
     
     motor[motorB] = -100;
     wait1Msec(650); //corrals the ball so that shooting force is greater
     motor[motorA] = 0;
     motor[motorC] = 0;
     motor[motorB] = 0;
     
     nMotorEncoder[motorB] = 0;
     motor[motorB] = 100;
     while(nMotorEncoder[motorB] <= 1080); //spins the motor a few times to 
                                           //ensure the ball is released with 
                                           //sufficient force to score 
     motor[motorB] = 0; //resets flipper motor to 0 for next use
}

bool senseBallDefense() //spins until it has sensed the ball
{
    motor[motorA] = -15;
    motor[motorC] = 15;
    wait1Msec(1000);
    int ball = 0;
    while(true)
    {
        nMotorEncoder[motorA] = 0;
        motor[motorA] = 15;
        motor[motorC] = -15;
        while(nMotorEncoder[motorA] <= 300)
        {
            ball = SensorRaw[Light];
            if(ball >= 300)
            {
                motor[motorA] = 0;
                motor[motorC] = 0;
                return true; //returns true if it has sensed the ball
            }
        }

        nMotorEncoder[motorC] = 0;
        motor[motorA] = -15;
        motor[motorC] = 15;
        while(nMotorEncoder[motorC] <= 300)
        {
            ball = SensorRaw[Light];
            if(ball >= 300)
            {
                motor[motorA] = 0;
                motor[motorC] = 0;
                return true; //returns true if it has sensed the ball
            }
        }
    }
}

void moveBotDefense() //attacks the ball at high speed to ensure ball does not
                      //score
{
    motor[motorB] = 100; //rotates the flipper for dramatic effect and in case
                         //ball gets corraled by the pincers

    for(int i=0; i<2; i++)
    {
        motor[motorA] = -90; //our motor has a problem with power balance, so 
                             //the %power for A and C differ slightly to correct
        motor[motorC] = -100;
        wait1Msec(500);
        
        motor[motorA] = -100;
        motor[motorC] = -90;
        wait1Msec(500);
    }
    
    motor[motorA] = 0;
    motor[motorB] = 0;
    motor[motorC] = 0;
}

/*
void moveToGoal() //positions the robot in the center of the net
{
    motor[motorA] = -10;
    motor[motorC] = 10;
    while(SensorValue[S1] > 200); //spins until it senses the goal
    wait10Msec(1000);

    motor[motorA] = 10;
    motor[motorC] = -10;
    while(SensorValue[S1] < 200); //rotates till it sees nothing
    motor[motorA] = 0;
    motor[motorC] = 0;

    nMotorEncoder[motorA] = 0;
    motor[motorA] = -10;
    motor[motorC] = 10;
    while(SensorValue[S1] < 200); //rotates till it sees the other side
    wait10Msec(1000);

    double center = nMotorEncoder[motorA]/2.0;
    motor[motorA] = 10;
    motor[motorC] = -10;
    nMotorEncoderTarget[motorA] = center;
    nMotorEncoderTarget[motorC] = center;


    while(SensorValue[S1] < 200) //goes forward until it is close to the net
	{
       motor[motorA] = 20;
       motor[motorC] = 20;
    }

    wait1Msec(200);
    motor[motorA] = -10; //turns the robot around to face the playing field
    motor[motorC] = 10;
    while(SensorValue[S1] > 10);
    wait1Msec(1000);
    motor[motorA] = 0;
    motor[motorC] = 0;
}
*/

task main()
{
    SensorType[S1] = sensorSONAR;
    SensorType[S2] = sensorTouch;
    SensorType[S3] = sensorCOLORRED;
    bool team = false; //attacking team or defending team
    while(nNxtButtonPressed != 3) //only exits if held after countdown finishes
    {
        nxtDisplayCenteredTextLine(0, "Group 34"); //centers text on line 0
        nxtDisplayCenteredTextLine(1, "Soccer Robot");
		if(!team) //if true, play attacking team
		{
		    wait1Msec(2000);
            senseBallOffense();
            moveBotOffense();
            wait1Msec(3000);
		    senseGoalOffense();
		    wait1Msec(1000);
		    shootBallOffense();
       }
       
       if(team) //if false, play defending team
	   {
	       wait1Msec(2000);
	       senseBallDefense();
		   wait1Msec(100);
		   
           nVolume = 100; //plays another sound file
  	       PlaySoundFile("allala.rso");
		
           moveBotDefense();
		   wait10Msec(100);
	  }
	  
      nxtDisplayString(2, "Hold touch sensor"); //asking the user to enter
	  nxtDisplayString(3, "in 10sec to      "); //they want the robot to play
	  nxtDisplayString(4, "change teams.    "); //offense or defense.
	  	  
      int i=10;
	  while(SensorValue[S2] == 0 && i>=1) //countdown from 10 seconds
	  {
          nxtDisplayString(5, "%d", i);
	      wait1Msec(1000);
	      i--;
	  }
	  
      if(i!=0)
  	      team = !team; //if user holds down the touch sensor, switches teams
	  eraseDisplay();
   }
}
